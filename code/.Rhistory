# return the coordinate of the bird
return(c(birdX,birdY))
}
checkMove <- function(newCoord, openSpaceX, openSpaceY) {
if (!any(newCoord[2] %in% openSpaceY[newCoord[1] == openSpaceX])) {
warning('New coordinate is not free. Bird will not move.')
return(F)
}
if (any(newCoord > 8 | newCoord < 1)) {
warning('New coordinate is beyodn the grid. Bird cannot move.')
return(F)
}
return(T)
}
moveBird <- function(oldCoord,newCoord,pigCoord,openSpaceX,openSpaceY) {
if (!checkMove(newCoord,openSpaceX,openSpaceY)) {
return(oldCoord)
}
segments(x0=oldCoord[1], y0=oldCoord[2],
x1=newCoord[1], y1=newCoord[2],
col='red')
mazeSolved(newCoord,pigCoord)
return(newCoord)
}
moveLeft <- function(openSpaceX, openSpaceY, birdCoord, pigCoord) {
return(moveBird(oldCoord=birdCoord,
newCoord = c(birdCoord[1]-1,
birdCoord[2]),
pigCoord = pigCoord,
openSpaceX = openSpaceX,
openSpaceY = openSpaceY))
}
moveRight <- function(openSpaceX, openSpaceY, birdCoord, pigCoord) {
return(moveBird(oldCoord=birdCoord,
newCoord = c(birdCoord[1]+1,
birdCoord[2]),
pigCoord = pigCoord,
openSpaceX = openSpaceX,
openSpaceY = openSpaceY))
}
moveUp <- function(openSpaceX, openSpaceY, birdCoord, pigCoord) {
return(moveBird(oldCoord=birdCoord,
newCoord = c(birdCoord[1],
birdCoord[2]+1),
pigCoord = pigCoord,
openSpaceX = openSpaceX,
openSpaceY = openSpaceY))
}
moveDown <- function(openSpaceX, openSpaceY, birdCoord, pigCoord) {
return(moveBird(oldCoord=birdCoord,
newCoord = c(birdCoord[1],
birdCoord[2]-1),
pigCoord = pigCoord,
openSpaceX = openSpaceX,
openSpaceY = openSpaceY))
}
createGrid <- function(openSpaceX,openSpaceY,birdCoord,pigCoord) {
# check that the X and Y coordinates of the open space match in size
if (length(openSpaceX)!=length(openSpaceY)) {
stop('Invalid number of open spaces. X and Y coordinates must match.')
}
# check that the birds and pigs are only at a single location
if (length(birdCoord) != 2 | length(pigCoord) != 2) {
stop('Invalid number of coordinates for bird or pig locations.')
}
birdX <- birdCoord[1]
birdY <- birdCoord[2]
pigX <- pigCoord[1]
pigY <- pigCoord[2]
# check that X and Y coordiantes of the open space fit the 8x8 grid
if (!all(openSpaceX %in% 1:8) |
!all(openSpaceY %in% 1:8) |
!(pigX %in% 1:8) |
!(pigY %in% 1:8) |
!(birdX %in% 1:8) |
!(birdY %in% 1:8)) {
stop('All input coordinates must fit in the 8xx grid.')
}
# set up the plotting area to create a grid for the maze
plot(c(0.5,8.5),c(0.5,8.5),col='white',xlab='',ylab='',axes=F)
# add labels to set the coordinates
axis(1,at=seq(from=1,to=8,by=1),labels=1:8)
axis(2,at=seq(from=1,to=8,by=1),labels=1:8)
# loop over each coordinate on the grid
for (x in 1:8) {
for (y in 1:8) {
# check to see if the given location is open
if (any(y %in% openSpaceY[openSpaceX==x])) {
# if it is open, create a white square
rect(xleft = x-0.5,ybottom = y-0.5,
xright = x+0.5, ytop = y+0.5, col='white',border='grey',lty=2)
} else {
# if it is not open, draw a black square
rect(xleft = x-0.5,ybottom = y-0.5,
xright = x+0.5, ytop = y+0.5, col='black',border='grey',lty=2)
}
}
}
# set the location of the bird
points(birdX,birdY,pch=19,col='red')
# set the location of the pig
points(pigX,pigY,pch=4,col='green')
# return the coordinate of the bird
return(c(birdX,birdY))
}
mazeSolved <- function(birdCoord, pigCoord) {
if (birdCoord[1]==pigCoord[1] && birdCoord[2]==pigCoord[2]) {
message('Congratulations, you got the pig!')
return(T)
} else {
message('Keep going...')
return(F)
}
}
demo()
demo(plotmath)
help("plot")
plot(cars)
createGrid <- function(openSpaceX,openSpaceY,birdCoord,pigCoord) {
# check that the X and Y coordinates of the open space match in size
if (length(openSpaceX)!=length(openSpaceY)) {
stop('Invalid number of open spaces. X and Y coordinates must match.')
}
# check that the birds and pigs are only at a single location
if (length(birdCoord) != 2 | length(pigCoord) != 2) {
stop('Invalid number of coordinates for bird or pig locations.')
}
birdX <- birdCoord[1]
birdY <- birdCoord[2]
pigX <- pigCoord[1]
pigY <- pigCoord[2]
# check that X and Y coordiantes of the open space fit the 8x8 grid
if (!all(openSpaceX %in% 1:8) |
!all(openSpaceY %in% 1:8) |
!(pigX %in% 1:8) |
!(pigY %in% 1:8) |
!(birdX %in% 1:8) |
!(birdY %in% 1:8)) {
stop('All input coordinates must fit in the 8xx grid.')
}
# set up the plotting area to create a grid for the maze
plot(c(0.5,8.5),c(0.5,8.5),col='white',xlab='',ylab='',axes=F)
# add labels to set the coordinates
axis(1,at=seq(from=1,to=8,by=1),labels=1:8)
axis(2,at=seq(from=1,to=8,by=1),labels=1:8)
# loop over each coordinate on the grid
for (x in 1:8) {
for (y in 1:8) {
# check to see if the given location is open
if (any(y %in% openSpaceY[openSpaceX==x])) {
# if it is open, create a white square
rect(xleft = x-0.5,ybottom = y-0.5,
xright = x+0.5, ytop = y+0.5, col='white',border='grey',lty=2)
} else {
# if it is not open, draw a black square
rect(xleft = x-0.5,ybottom = y-0.5,
xright = x+0.5, ytop = y+0.5, col='black',border='grey',lty=2)
}
}
}
# set the location of the bird
points(birdX,birdY,pch=19,col='red')
# set the location of the pig
points(pigX,pigY,pch=4,col='green')
# return the coordinate of the bird
return(c(birdX,birdY))
}
createGrid <- function(openSpaceX,openSpaceY,birdCoord,pigCoord) {
# check that the X and Y coordinates of the open space match in size
if (length(openSpaceX)!=length(openSpaceY)) {
stop('Invalid number of open spaces. X and Y coordinates must match.')
}
# check that the birds and pigs are only at a single location
if (length(birdCoord) != 2 | length(pigCoord) != 2) {
stop('Invalid number of coordinates for bird or pig locations.')
}
birdX <- birdCoord[1]
birdY <- birdCoord[2]
pigX <- pigCoord[1]
pigY <- pigCoord[2]
# check that X and Y coordiantes of the open space fit the 8x8 grid
if (!all(openSpaceX %in% 1:8) |
!all(openSpaceY %in% 1:8) |
!(pigX %in% 1:8) |
!(pigY %in% 1:8) |
!(birdX %in% 1:8) |
!(birdY %in% 1:8)) {
stop('All input coordinates must fit in the 8xx grid.')
}
# set up the plotting area to create a grid for the maze
plot(c(0.5,8.5),c(0.5,8.5),col='white',xlab='',ylab='',axes=F)
# add labels to set the coordinates
axis(1,at=seq(from=1,to=8,by=1),labels=1:8)
axis(2,at=seq(from=1,to=8,by=1),labels=1:8)
# loop over each coordinate on the grid
for (x in 1:8) {
for (y in 1:8) {
# check to see if the given location is open
if (any(y %in% openSpaceY[openSpaceX==x])) {
# if it is open, create a white square
rect(xleft = x-0.5,ybottom = y-0.5,
xright = x+0.5, ytop = y+0.5, col='white',border='grey',lty=2)
} else {
# if it is not open, draw a black square
rect(xleft = x-0.5,ybottom = y-0.5,
xright = x+0.5, ytop = y+0.5, col='black',border='grey',lty=2)
}
}
}
# set the location of the bird
points(birdX,birdY,pch=19,col='red')
# set the location of the pig
points(pigX,pigY,pch=4,col='green')
# return the coordinate of the bird
return(c(birdX,birdY))
}
mazeSolved <- function(birdCoord, pigCoord) {
if (birdCoord[1]==pigCoord[1] && birdCoord[2]==pigCoord[2]) {
message('Congratulations, you got the pig!')
return(T)
} else {
message('Keep going...')
return(F)
}
}
createGrid(1:9,rep(1,9),c(1,1),c(3,1))
createGrid(1:3,rep(1,3),c(1,1),c(3,1))
createGrid(1:3,rep(1,5),c(1,1),c(3,1))
createGrid(1:3,(1:5),c(1,1),c(3,1))
createGrid(1:3,(1:3),c(1,1),c(3,1))
createGrid(1:5,rep(3,5),c(1,1),c(3,1))
createGrid(1:5,rep(3,5),c(1,3),c(3,3))
createGrid(1:3,rep(1,5),c(1,1),c(3,1))
createGrid(1:3,rep(1,3),c(1,1),c(3,1))
Exercise 1
---
Write a function `mazeSolved` to return a Boolean to indicate whether the bird has reached the pig. If it has, use the `message` function to let the user know that they have won the game.
```{r,echo=F}
mazeSolved <- function(birdCoord, pigCoord) {
if (birdCoord[1]==pigCoord[1] && birdCoord[2]==pigCoord[2]) {
message('Congratulations, you got the pig!')
return(T)
} else {
message('Keep going...')
return(F)
}
}
```
mazeSolved <- function(birdCoord, pigCoord) {
if (birdCoord[1]==pigCoord[1] && birdCoord[2]==pigCoord[2]) {
message('Congratulations, you got the pig!')
return(T)
} else {
message('Keep going...')
return(F)
}
}
createGrid(1:3,rep(1,3),c(1,1),c(3,1))
checkMove <- function(newCoord, openSpaceX, openSpaceY) {
if (!any(newCoord[2] %in% openSpaceY[newCoord[1] == openSpaceX])) {
warning('New coordinate is not free. Bird will not move.')
return(F)
}
if (any(newCoord > 8 | newCoord < 1)) {
warning('New coordinate is beyodn the grid. Bird cannot move.')
return(F)
}
return(T)
}
moveBird <- function(oldCoord,newCoord,pigCoord,openSpaceX,openSpaceY) {
if (!checkMove(newCoord,openSpaceX,openSpaceY)) {
return(oldCoord)
}
segments(x0=oldCoord[1], y0=oldCoord[2],
x1=newCoord[1], y1=newCoord[2],
col='red')
mazeSolved(newCoord,pigCoord)
return(newCoord)
}
moveLeft <- function(openSpaceX, openSpaceY, birdCoord, pigCoord) {
return(moveBird(oldCoord=birdCoord,
newCoord = c(birdCoord[1]-1,
birdCoord[2]),
pigCoord = pigCoord,
openSpaceX = openSpaceX,
openSpaceY = openSpaceY))
}
moveRight <- function(openSpaceX, openSpaceY, birdCoord, pigCoord) {
return(moveBird(oldCoord=birdCoord,
newCoord = c(birdCoord[1]+1,
birdCoord[2]),
pigCoord = pigCoord,
openSpaceX = openSpaceX,
openSpaceY = openSpaceY))
}
moveUp <- function(openSpaceX, openSpaceY, birdCoord, pigCoord) {
return(moveBird(oldCoord=birdCoord,
newCoord = c(birdCoord[1],
birdCoord[2]+1),
pigCoord = pigCoord,
openSpaceX = openSpaceX,
openSpaceY = openSpaceY))
}
moveDown <- function(openSpaceX, openSpaceY, birdCoord, pigCoord) {
return(moveBird(oldCoord=birdCoord,
newCoord = c(birdCoord[1],
birdCoord[2]-1),
pigCoord = pigCoord,
openSpaceX = openSpaceX,
openSpaceY = openSpaceY))
}
moveBird((1,1), (3,1), (3, 1), (1:3), rep(1,3))
moveBird((1,1) (3,1) (3, 1) (1:3) rep(1,3))
moveBird((1), (3), (3, 1), (1:3), rep(1,3))
moveBird((1), (3), (3), (1:3), rep(1,3))
moveBird((1 1), (3 1), (3 1), (1:3), rep(1,3))
moveBird([1,1]), [3,1], [3,1], (1:3), rep(1,3))
moveBird((1,1), (2,1), (3,1), (1:3), rep(1,3))
moveBird((1,1), (3), (3,1), (1:3), rep(1,3))
moveBird(c(1,1), c(3,1), c(3,1), (1:3), rep(1,3))
View(moveBird)
View(moveDown)
View(moveBird)
moveBird(c(3,1), c(1,1), c(1,1), (1:3), rep(1,3))
moveBird((1 1), (3 1), (3 1), (1:3), rep(1,3))
moveBird(oldCoord(1,1), newCoord(3,1), pigCoord(3,1), (1:3), rep(1,3))
moveBird(c(3,1), c(1,1), c(1,1), (1:3), rep(1,3))
oldCoord <- c(1,3)
oldCoord <- c(1,1)
newCoord <- c(3,1)
pigCoord <- c(3,1)
moveBird(oldCoord, newCoord, pigCoord, (1:3), rep(1,3))
createGrid(1:3,rep(1,3),c(1,1),c(3,1))
mazeSolved <- function(birdCoord, pigCoord) {
if (birdCoord[1]==pigCoord[1] && birdCoord[2]==pigCoord[2]) {
message('Congratulations, you got the pig!')
return(T)
} else {
message('Keep going...')
return(F)
}
}
birdCoord <- createGrid(openSpaceX = openSpaceX,
openSpaceY=openSpaceY,
birdCoord=birdCoord,
pigCoord=pigCoord)
height <- c(145, 167, 176, 123, 150)
weight <- c(51, 63, 64, 40, 55)
plot(height,weight)
createGrid(1:3,rep(1,3),c(1,1),c(3,1))
checkMove <- function(newCoord, openSpaceX, openSpaceY) {
if (!any(newCoord[2] %in% openSpaceY[newCoord[1] == openSpaceX])) {
warning('New coordinate is not free. Bird will not move.')
return(F)
}
if (any(newCoord > 8 | newCoord < 1)) {
warning('New coordinate is beyodn the grid. Bird cannot move.')
return(F)
}
return(T)
}
moveBird <- function(oldCoord,newCoord,pigCoord,openSpaceX,openSpaceY) {
if (!checkMove(newCoord,openSpaceX,openSpaceY)) {
return(oldCoord)
}
segments(x0=oldCoord[1], y0=oldCoord[2],
x1=newCoord[1], y1=newCoord[2],
col='red')
mazeSolved(newCoord,pigCoord)
return(newCoord)
}
moveLeft <- function(openSpaceX, openSpaceY, birdCoord, pigCoord) {
return(moveBird(oldCoord=birdCoord,
newCoord = c(birdCoord[1]-1,
birdCoord[2]),
pigCoord = pigCoord,
openSpaceX = openSpaceX,
openSpaceY = openSpaceY))
}
moveRight <- function(openSpaceX, openSpaceY, birdCoord, pigCoord) {
return(moveBird(oldCoord=birdCoord,
newCoord = c(birdCoord[1]+1,
birdCoord[2]),
pigCoord = pigCoord,
openSpaceX = openSpaceX,
openSpaceY = openSpaceY))
}
moveUp <- function(openSpaceX, openSpaceY, birdCoord, pigCoord) {
return(moveBird(oldCoord=birdCoord,
newCoord = c(birdCoord[1],
birdCoord[2]+1),
pigCoord = pigCoord,
openSpaceX = openSpaceX,
openSpaceY = openSpaceY))
}
moveDown <- function(openSpaceX, openSpaceY, birdCoord, pigCoord) {
return(moveBird(oldCoord=birdCoord,
newCoord = c(birdCoord[1],
birdCoord[2]-1),
pigCoord = pigCoord,
openSpaceX = openSpaceX,
openSpaceY = openSpaceY))
}
pigCoord <- c(3,4)
birdCoord <- c(3,6)
openSpaceX <- rep(3,3)
openSpaceY <- 4:6
birdCoord <- createGrid(openSpaceX = openSpaceX,
openSpaceY=openSpaceY,
birdCoord=birdCoord,
pigCoord=pigCoord)
pigCoord <- c(7,5)
birdCoord <- c(2,5)
openSpaceX <- 2:7
openSpaceY <- rep(5,6)
birdCoord <- createGrid(openSpaceX = openSpaceX,
openSpaceY=openSpaceY,
birdCoord=birdCoord,
pigCoord=pigCoord)
pigCoord <- c(7,5)
birdCoord <- c(2,5)
openSpaceX <- 2:7
openSpaceY <- rep(5,6)
birdCoord <- createGrid(openSpaceX = openSpaceX,
openSpaceY=openSpaceY,
birdCoord=birdCoord,
pigCoord=pigCoord)
birdCoord  <- moveRight(birdCoord = birdCoord,
pigCoord = pigCoord,
openSpaceX = openSpaceX,
openSpaceY = openSpaceY)
for (i in 1:5) {
birdCoord  <- moveRight(birdCoord = birdCoord,
pigCoord = pigCoord,
openSpaceX = openSpaceX,
openSpaceY = openSpaceY)
{r}
data("iris")
data()
knitr::opts_chunk$set(echo = TRUE)
data("iris")
head(iris)
iris[iris$Species != "setosa"]
iris[iris$Species != "setosa",]
sim(iris[iris$Species != "setosa" & iris$Petal.Length>=5,])
dim(iris[iris$Species != "setosa" & iris$Petal.Length>=5,])
iris[iris$Species == "setosa", "Petal.Length"]
mean(iris[iris$Species == "setosa", "Petal.Length"])
plot(iris[iris$Species == "setosa", "Petal.Length"])
plot(iris[iris$Species == "setosa" ~ "Petal.Length"])
load("/Users/laurenpeiffer/Downloads/StringHandlingSampleData.Rda")
setwd("/Volumes/My Passport/Sequencing/it-workflow/code")
rm(list=ls()) #reset of all commands in system
library(RColorBrewer) #install these packages first
library(ggplot2)
library(grid)
library(reshape2)
# ---------------------------------------------------
# configure per user ---
#setwd("it-workflow/code") # git repository already cloned to desktop
analysisdir = "../analysis/P21-alpha-vis" #create the analysis directory you want outputs to go into
unlink(analysisdir, recursive=TRUE)
dir.create(analysisdir)
# ---------------------------------------------------
pdfdir = paste(analysisdir, "/pdfs/", sep="")
unlink(pdfdir, recursive=TRUE)
dir.create(pdfdir)
# ---------------------------------------------------
tablefile = "../analysis/P08-filtered-sum-alpha/alpha-diversity-per-sample-region.txt"
A <- read.table(tablefile, sep="\t", header=TRUE, check.names=FALSE, as.is=TRUE)
meltA <- melt(A, id.vars=c("Region", "SampleID"))
colnames(meltA) = c("Region", "SampleID", "Measure", "Value")
meltA$Measure = gsub("exported-","", meltA$Measure)
meltA$Measure = gsub("-vector","", meltA$Measure)
meltA$Measure = gsub("evenness","Evenness", meltA$Measure)
meltA$Measure = gsub("faith-pd","Faith's-PD", meltA$Measure)
meltA$Measure = gsub("observed-otus","Observed-OTUs", meltA$Measure)
meltA$Measure = gsub("shannon","Shannon", meltA$Measure)
# --------------------------------------------------------
# BEGIN color scheme for major sample metadata features of interest ---------
mycolors = c()
mycolors$Region["v2"]  = "#FF9AA2"
mycolors$Region["v3"]  = "#FFDAC1"
mycolors$Region["v4"]  = "#FFF7C1"
mycolors$Region["v67"] = "#E2F0CB"
mycolors$Region["v8"]  = "#B5EAD7"
mycolors$Region["v9"]  = "#C7CEEA"
mycolors$SampleID["atcc1"] = "#F2978B"
mycolors$SampleID["atcc2"] = "#D954A0"
mycolors$SampleID["atcc3"] = "#6D5FA6"
mycolors$SampleID["atcc4"] = "#518FBF"
mycolors$SampleID["atcc5"] = "#63BBBF"
# END color scheme for major sample metadata features of interest ---------
# --------------------------------------------------------
outfile1 = paste(pdfdir, "alpha-diversity-by-region.pdf", sep="")
p1 <- ggplot(meltA, aes(x=Region, y=Value)) +
geom_boxplot(mapping=aes(color=Region), alpha=1, outlier.size = NA, coef=1000) +
geom_point(aes(color=Region), alpha=1, size=2) +
theme_bw() +
scale_color_manual(values=mycolors$Region) +
theme(axis.text.x  = element_text(size=11, colour="black"),
axis.text.y  = element_text(size=11, colour="black"),
axis.title.x = element_text(size=12, colour="black"),
axis.title.y = element_text(size=12, colour="black"),
plot.title   = element_text(size=10, colour="black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
aspect.ratio=1.0) +
xlab(NULL) +
ylab("Measure Value") +
facet_wrap(~Measure, ncol=2, scales="free_y")
ggsave(outfile1, plot=p1)
