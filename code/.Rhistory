}else if(maxValConcordanceChrPosLevelAnno[i,"top_stratafide_call"] != "n/a" &
maxValConcordanceChrPosLevelAnno[i,"top_avenio_call"]     == "n/a"){
threshold = avenioSNVIndelLOD
if (muttype == "CNV"){
threshold = 0
}
if (as.numeric(maxValConcordanceChrPosLevelAnno[i,"top_strat_AF_or_CNV_obs_copies"])  >= threshold){
Xpn = Xpn + 1
}
}else if(maxValConcordanceChrPosLevelAnno[i,"top_stratafide_call"] == "n/a" &
maxValConcordanceChrPosLevelAnno[i,"top_avenio_call"]     != "n/a"){
threshold = avenioSNVIndelLOD
if (muttype == "CNV"){
threshold = avenioCNVLoD
}
if (as.numeric(maxValConcordanceChrPosLevelAnno[i,"top_avenio_AF_or_CNV_score"])  >= threshold){
Xnp = Xnp + 1
}
}
} # end of i loop
# compute the full NPA, OPA we need to infer to the TN counts
# based on mutation type
mutN = 3 # for CNVs
if (muttype == "SNV"){
mutN = 496 # this is the shared SNV/MNV position coverage between assays
}
if (muttype == "Indel"){
mutN = 39  # this is the shared Indel position coverage between assays
}
Xnn    = mutN - Xpp - Xpn - Xnp
OPAres = c(muttype, "OPA", prctAggResRow((Xpp+Xnn), (Xpp+Xnp+Xpn+Xnn)))
PPAres = c(muttype, "PPA", prctAggResRow(Xpp, Xpp+Xnp))
NPAres = c(muttype, "NPA", prctAggResRow(Xnn, Xnn+Xpn))
tab.10a = rbind(tab.10a, c(aset, as.character(comparison_manifest[speci,"tissue_kind"]), OPAres),
c(aset, as.character(comparison_manifest[speci,"tissue_kind"]), PPAres),
c(aset, as.character(comparison_manifest[speci,"tissue_kind"]), NPAres))
tab.10b = rbind(tab.10b, c(aset, as.character(comparison_manifest[speci,"tissue_kind"]), muttype,Xpp,Xnp,Xnn,Xpn,Xip,Xin))
}
}
tab.10a = data.frame(tab.10a)
tab.10b = data.frame(tab.10b)
colnames(tab.10a) = c("Specimen ID", "Specimen Type", "Variant Type", "Comparison", "N Denominator", "n Agree", "Percent Agreement", "(LB, UB)")
colnames(tab.10b) = c("Specimen ID", "Specimen Type", "Variant Type", "PRESENT/PRESENT",	"PRESENT/ABSENT",
"ABSENT/ABSENT",	  "ABSENT/PRESENT",
"PRESENT/IND",     "ABSENT/IND")
write_csv_to_s3(tab.10a, 's3://archer-stats-data-management/Stratafide/ctDNA/DHF17-A-3-2/STAT/STAT_ANALYSIS_OUTPUT/AgreementStatSampVT.csv')
write_csv_to_s3(tab.10b, 's3://archer-stats-data-management/Stratafide/ctDNA/DHF17-A-3-2/STAT/STAT_ANALYSIS_OUTPUT/Counts_for_Agreement_SampVT.csv')
tab.10a
View(tab.10a)
View(tab.10b)
# -----
# Table 11a. Agreement by Gene and Variant Type (No Calls Excluded)
# Table 11b. Counts for Agreement by Gene and Variant Type (No Calls Excluded)
# read in mut type counts by gene
mutTypeByGene = read.table("coordinate-mapping-info/mutTypebyGene.txt", header=TRUE, sep="\t") %>%
mutate_all(as.character)
tab.11a = c()
tab.11b = c()
for (aset in sort(unique(maxValConcordanceChrPosLevelAnno$gene))){
for (muttype in muttypes){
if (!grepl("EGFR|MET|ERBB2", aset) & muttype=="CNV"){
next
}
print(paste("Secondary Analysis (variant level) by gene", aset, muttype,"...",sep=" "))
Xpp = 0
Xnp = 0
Xpn = 0
Xnn = 0
Xip = 0
Xin = 0
for (i in 1:nrow(maxValConcordanceChrPosLevelAnno)){
if (maxValConcordanceChrPosLevelAnno[i,"mutation_class"] != muttype){
next
}
if (maxValConcordanceChrPosLevelAnno[i,"gene"] != aset){
next
}
# if both detect or not detect concordantly (Xpp and Xnn)
# otherwise use the LoD requirement to establish discordant calls
if (maxValConcordanceChrPosLevelAnno[i,"top_stratafide_call"] != "n/a" &
maxValConcordanceChrPosLevelAnno[i,"top_avenio_call"]     != "n/a"){
Xpp = Xpp + 1
}else if(maxValConcordanceChrPosLevelAnno[i,"top_stratafide_call"] == "n/a" &
maxValConcordanceChrPosLevelAnno[i,"top_avenio_call"]     == "n/a"){
Xnn = Xnn + 1
}else if(maxValConcordanceChrPosLevelAnno[i,"top_stratafide_call"] != "n/a" &
maxValConcordanceChrPosLevelAnno[i,"top_avenio_call"]     == "n/a"){
threshold = avenioSNVIndelLOD
if (muttype == "CNV"){
threshold = 0
}
if (as.numeric(maxValConcordanceChrPosLevelAnno[i,"top_strat_AF_or_CNV_obs_copies"])  >= threshold){
Xpn = Xpn + 1
}
}else if(maxValConcordanceChrPosLevelAnno[i,"top_stratafide_call"] == "n/a" &
maxValConcordanceChrPosLevelAnno[i,"top_avenio_call"]     != "n/a"){
threshold = avenioSNVIndelLOD
if (muttype == "CNV"){
threshold = avenioCNVLoD
}
if (as.numeric(maxValConcordanceChrPosLevelAnno[i,"top_avenio_AF_or_CNV_score"])  >= threshold){
Xnp = Xnp + 1
}
}
} # end of i loop
# compute the full NPA, OPA we need to infer to the TN counts
# based on mutation type
mutN = 1 # for CNVs
if (muttype == "SNV"){
mutN = as.numeric(as.character(mutTypeByGene[mutTypeByGene$Gene == gene,"SNV"]))
# this is the shared SNV/MNV position coverage between assays for that gene
}
if (muttype == "Indel"){
mutN = as.numeric(as.character(mutTypeByGene[mutTypeByGene$Gene == gene,"Indel"]))
# this is the shared Indel position coverage between assays for that gene
}
Xnn    = nrow(comparison_manifest)*mutN - Xpp - Xpn - Xnp
OPAres = c(muttype, "OPA", prctAggResRow((Xpp+Xnn), (Xpp+Xnp+Xpn+Xnn)))
PPAres = c(muttype, "PPA", prctAggResRow(Xpp, Xpp+Xnp))
NPAres = c(muttype, "NPA", prctAggResRow(Xnn, Xnn+Xpn))
tab.11a = rbind(tab.11a, c(aset, OPAres),
c(aset, PPAres),
c(aset, NPAres))
tab.11b = rbind(tab.11b, c(aset,muttype,Xpp,Xnp,Xnn,Xpn,Xip,Xin))
}
}
tab.11a = data.frame(tab.11a)
tab.11b = data.frame(tab.11b)
colnames(tab.11a) = c("Gene", "Variant Type", "Comparison", "N Denominator", "n Agree", "Percent Agreement", "(LB, UB)")
colnames(tab.11b) = c("Gene", "Variant Type", "PRESENT/PRESENT",	"PRESENT/ABSENT",
"ABSENT/ABSENT",	  "ABSENT/PRESENT",
"PRESENT/IND",     "ABSENT/IND")
write_csv_to_s3(tab.11a, 's3://archer-stats-data-management/Stratafide/ctDNA/DHF17-A-3-2/STAT/STAT_ANALYSIS_OUTPUT/AgreementStatGenVT.csv')
write_csv_to_s3(tab.11b, 's3://archer-stats-data-management/Stratafide/ctDNA/DHF17-A-3-2/STAT/STAT_ANALYSIS_OUTPUT/Counts_for_Agreement_GenVT.csv')
mutTypeByGene
sort(unique(maxValConcordanceChrPosLevelAnno$gene))
# -----
# Table 11a. Agreement by Gene and Variant Type (No Calls Excluded)
# Table 11b. Counts for Agreement by Gene and Variant Type (No Calls Excluded)
# read in mut type counts by gene
mutTypeByGene = read.table("coordinate-mapping-info/mutTypebyGene.txt", header=TRUE, sep="\t") %>%
mutate_all(as.character)
tab.11a = c()
tab.11b = c()
for (aset in sort(unique(maxValConcordanceChrPosLevelAnno$gene))){
for (muttype in muttypes){
if (!grepl("EGFR|MET|ERBB2", aset) & muttype=="CNV"){
next
}
print(paste("Secondary Analysis (variant level) by gene", aset, muttype,"...",sep=" "))
Xpp = 0
Xnp = 0
Xpn = 0
Xnn = 0
Xip = 0
Xin = 0
for (i in 1:nrow(maxValConcordanceChrPosLevelAnno)){
if (maxValConcordanceChrPosLevelAnno[i,"mutation_class"] != muttype){
next
}
if (maxValConcordanceChrPosLevelAnno[i,"gene"] != aset){
next
}
# if both detect or not detect concordantly (Xpp and Xnn)
# otherwise use the LoD requirement to establish discordant calls
if (maxValConcordanceChrPosLevelAnno[i,"top_stratafide_call"] != "n/a" &
maxValConcordanceChrPosLevelAnno[i,"top_avenio_call"]     != "n/a"){
Xpp = Xpp + 1
}else if(maxValConcordanceChrPosLevelAnno[i,"top_stratafide_call"] == "n/a" &
maxValConcordanceChrPosLevelAnno[i,"top_avenio_call"]     == "n/a"){
Xnn = Xnn + 1
}else if(maxValConcordanceChrPosLevelAnno[i,"top_stratafide_call"] != "n/a" &
maxValConcordanceChrPosLevelAnno[i,"top_avenio_call"]     == "n/a"){
threshold = avenioSNVIndelLOD
if (muttype == "CNV"){
threshold = 0
}
if (as.numeric(maxValConcordanceChrPosLevelAnno[i,"top_strat_AF_or_CNV_obs_copies"])  >= threshold){
Xpn = Xpn + 1
}
}else if(maxValConcordanceChrPosLevelAnno[i,"top_stratafide_call"] == "n/a" &
maxValConcordanceChrPosLevelAnno[i,"top_avenio_call"]     != "n/a"){
threshold = avenioSNVIndelLOD
if (muttype == "CNV"){
threshold = avenioCNVLoD
}
if (as.numeric(maxValConcordanceChrPosLevelAnno[i,"top_avenio_AF_or_CNV_score"])  >= threshold){
Xnp = Xnp + 1
}
}
} # end of i loop
# compute the full NPA, OPA we need to infer to the TN counts
# based on mutation type
mutN = 1 # for CNVs
if (muttype == "SNV"){
mutN = as.numeric(as.character(mutTypeByGene[mutTypeByGene$Gene == gene,"SNV"]))
# this is the shared SNV/MNV position coverage between assays for that gene
}
if (muttype == "Indel"){
mutN = as.numeric(as.character(mutTypeByGene[mutTypeByGene$Gene == gene,"Indel"]))
# this is the shared Indel position coverage between assays for that gene
}
Xnn    = nrow(comparison_manifest)*mutN - Xpp - Xpn - Xnp
OPAres = c(muttype, "OPA", prctAggResRow((Xpp+Xnn), (Xpp+Xnp+Xpn+Xnn)))
PPAres = c(muttype, "PPA", prctAggResRow(Xpp, Xpp+Xnp))
NPAres = c(muttype, "NPA", prctAggResRow(Xnn, Xnn+Xpn))
tab.11a = rbind(tab.11a, c(aset, muttype, OPAres),
c(aset, muttype, PPAres),
c(aset, muttype, NPAres))
tab.11b = rbind(tab.11b, c(aset,muttype,Xpp,Xnp,Xnn,Xpn,Xip,Xin))
}
}
tab.11a = data.frame(tab.11a)
tab.11b = data.frame(tab.11b)
colnames(tab.11a) = c("Gene", "Variant Type", "Comparison", "N Denominator", "n Agree", "Percent Agreement", "(LB, UB)")
colnames(tab.11b) = c("Gene", "Variant Type", "PRESENT/PRESENT",	"PRESENT/ABSENT",
"ABSENT/ABSENT",	  "ABSENT/PRESENT",
"PRESENT/IND",     "ABSENT/IND")
write_csv_to_s3(tab.11a, 's3://archer-stats-data-management/Stratafide/ctDNA/DHF17-A-3-2/STAT/STAT_ANALYSIS_OUTPUT/AgreementStatGenVT.csv')
write_csv_to_s3(tab.11b, 's3://archer-stats-data-management/Stratafide/ctDNA/DHF17-A-3-2/STAT/STAT_ANALYSIS_OUTPUT/Counts_for_Agreement_GenVT.csv')
# -----
as.numeric(as.character(mutTypeByGene[mutTypeByGene$Gene == gene,"SNV"]))
mutTypeByGene[mutTypeByGene$Gene == gene,"SNV"]
gene
# -----
# Table 11a. Agreement by Gene and Variant Type (No Calls Excluded)
# Table 11b. Counts for Agreement by Gene and Variant Type (No Calls Excluded)
# read in mut type counts by gene
mutTypeByGene = read.table("coordinate-mapping-info/mutTypebyGene.txt", header=TRUE, sep="\t") %>%
mutate_all(as.character)
tab.11a = c()
tab.11b = c()
for (aset in sort(unique(maxValConcordanceChrPosLevelAnno$gene))){
for (muttype in muttypes){
if (!grepl("EGFR|MET|ERBB2", aset) & muttype=="CNV"){
next
}
print(paste("Secondary Analysis (variant level) by gene", aset, muttype,"...",sep=" "))
Xpp = 0
Xnp = 0
Xpn = 0
Xnn = 0
Xip = 0
Xin = 0
for (i in 1:nrow(maxValConcordanceChrPosLevelAnno)){
if (maxValConcordanceChrPosLevelAnno[i,"mutation_class"] != muttype){
next
}
if (maxValConcordanceChrPosLevelAnno[i,"gene"] != aset){
next
}
# if both detect or not detect concordantly (Xpp and Xnn)
# otherwise use the LoD requirement to establish discordant calls
if (maxValConcordanceChrPosLevelAnno[i,"top_stratafide_call"] != "n/a" &
maxValConcordanceChrPosLevelAnno[i,"top_avenio_call"]     != "n/a"){
Xpp = Xpp + 1
}else if(maxValConcordanceChrPosLevelAnno[i,"top_stratafide_call"] == "n/a" &
maxValConcordanceChrPosLevelAnno[i,"top_avenio_call"]     == "n/a"){
Xnn = Xnn + 1
}else if(maxValConcordanceChrPosLevelAnno[i,"top_stratafide_call"] != "n/a" &
maxValConcordanceChrPosLevelAnno[i,"top_avenio_call"]     == "n/a"){
threshold = avenioSNVIndelLOD
if (muttype == "CNV"){
threshold = 0
}
if (as.numeric(maxValConcordanceChrPosLevelAnno[i,"top_strat_AF_or_CNV_obs_copies"])  >= threshold){
Xpn = Xpn + 1
}
}else if(maxValConcordanceChrPosLevelAnno[i,"top_stratafide_call"] == "n/a" &
maxValConcordanceChrPosLevelAnno[i,"top_avenio_call"]     != "n/a"){
threshold = avenioSNVIndelLOD
if (muttype == "CNV"){
threshold = avenioCNVLoD
}
if (as.numeric(maxValConcordanceChrPosLevelAnno[i,"top_avenio_AF_or_CNV_score"])  >= threshold){
Xnp = Xnp + 1
}
}
} # end of i loop
# compute the full NPA, OPA we need to infer to the TN counts
# based on mutation type
mutN = 1 # for CNVs
if (muttype == "SNV"){
mutN = as.numeric(as.character(mutTypeByGene[mutTypeByGene$Gene == aset,"SNV"]))
# this is the shared SNV/MNV position coverage between assays for that gene
}
if (muttype == "Indel"){
mutN = as.numeric(as.character(mutTypeByGene[mutTypeByGene$Gene == aset,"Indel"]))
# this is the shared Indel position coverage between assays for that gene
}
Xnn    = nrow(comparison_manifest)*mutN - Xpp - Xpn - Xnp
OPAres = c(muttype, "OPA", prctAggResRow((Xpp+Xnn), (Xpp+Xnp+Xpn+Xnn)))
PPAres = c(muttype, "PPA", prctAggResRow(Xpp, Xpp+Xnp))
NPAres = c(muttype, "NPA", prctAggResRow(Xnn, Xnn+Xpn))
tab.11a = rbind(tab.11a, c(aset, muttype, OPAres),
c(aset, muttype, PPAres),
c(aset, muttype, NPAres))
tab.11b = rbind(tab.11b, c(aset,muttype,Xpp,Xnp,Xnn,Xpn,Xip,Xin))
}
}
tab.11a = data.frame(tab.11a)
tab.11b = data.frame(tab.11b)
colnames(tab.11a) = c("Gene", "Variant Type", "Comparison", "N Denominator", "n Agree", "Percent Agreement", "(LB, UB)")
colnames(tab.11b) = c("Gene", "Variant Type", "PRESENT/PRESENT",	"PRESENT/ABSENT",
"ABSENT/ABSENT",	  "ABSENT/PRESENT",
"PRESENT/IND",     "ABSENT/IND")
write_csv_to_s3(tab.11a, 's3://archer-stats-data-management/Stratafide/ctDNA/DHF17-A-3-2/STAT/STAT_ANALYSIS_OUTPUT/AgreementStatGenVT.csv')
write_csv_to_s3(tab.11b, 's3://archer-stats-data-management/Stratafide/ctDNA/DHF17-A-3-2/STAT/STAT_ANALYSIS_OUTPUT/Counts_for_Agreement_GenVT.csv')
tab.11a
View(tab.11a)
# -----
# Table 12a. Agreement by Tumor Type and Variant Type (No Calls Excluded)
# Table 12b. Counts for Agreement by Tumor Type and Variant Type (No Calls Excluded)
tab.12a = c()
tab.12b = c()
for (aset in sort(unique(maxValConcordanceChrPosLevelAnno$tissue_of_origin))){
for (muttype in muttypes){
print(paste("Secondary Analysis (variant level)", aset, muttype,"...",sep=" "))
Xpp = 0
Xnp = 0
Xpn = 0
Xnn = 0
Xip = 0
Xin = 0
for (i in 1:nrow(maxValConcordanceChrPosLevelAnno)){
if (maxValConcordanceChrPosLevelAnno[i,"mutation_class"] != muttype){
next
}
if (aset != as.character(maxValConcordanceChrPosLevelAnno[i,"tissue_of_origin"])){
next
}
# if both detect or not detect concordantly (Xpp and Xnn)
# otherwise use the LoD requirement to establish discordant calls
if (maxValConcordanceChrPosLevelAnno[i,"top_stratafide_call"] != "n/a" &
maxValConcordanceChrPosLevelAnno[i,"top_avenio_call"]     != "n/a"){
Xpp = Xpp + 1
}else if(maxValConcordanceChrPosLevelAnno[i,"top_stratafide_call"] == "n/a" &
maxValConcordanceChrPosLevelAnno[i,"top_avenio_call"]     == "n/a"){
Xnn = Xnn + 1
}else if(maxValConcordanceChrPosLevelAnno[i,"top_stratafide_call"] != "n/a" &
maxValConcordanceChrPosLevelAnno[i,"top_avenio_call"]     == "n/a"){
threshold = avenioSNVIndelLOD
if (muttype == "CNV"){
threshold = 0
}
if (as.numeric(maxValConcordanceChrPosLevelAnno[i,"top_strat_AF_or_CNV_obs_copies"])  >= threshold){
Xpn = Xpn + 1
}
}else if(maxValConcordanceChrPosLevelAnno[i,"top_stratafide_call"] == "n/a" &
maxValConcordanceChrPosLevelAnno[i,"top_avenio_call"]     != "n/a"){
threshold = avenioSNVIndelLOD
if (muttype == "CNV"){
threshold = avenioCNVLoD
}
if (as.numeric(maxValConcordanceChrPosLevelAnno[i,"top_avenio_AF_or_CNV_score"])  >= threshold){
Xnp = Xnp + 1
}
}
} # end of i loop
# compute the full NPA, OPA we need to infer to the TN counts
# based on mutation type
mutN = 3 # for CNVs if included
if (muttype == "SNV"){
mutN = 40 # this is the shared SNV/MNV position coverage between assays
}
if (muttype == "Indel"){
mutN = 10  # this is the shared Indel position coverage between assays
}
Xnn = nrow(comparison_manifest)*mutN - Xpp - Xpn - Xnp
OPAres = c(muttype, "OPA", prctAggResRow((Xpp+Xnn), (Xpp+Xnp+Xpn+Xnn)))
PPAres = c(muttype, "PPA", prctAggResRow(Xpp, Xpp+Xnp))
NPAres = c(muttype, "NPA", prctAggResRow(Xnn, Xnn+Xpn))
tab.12a = rbind(tab.12a, c(aset,OPAres),
c(aset,PPAres),
c(aset,NPAres))
tab.12b = rbind(tab.12b, c(aset,muttype,Xpp,Xnp,Xnn,Xpn,Xip,Xin))
}
}
tab.12a = data.frame(tab.12a)
tab.12b = data.frame(tab.12b)
colnames(tab.12a) = c("Tumor Type", "Variant Type", "Comparison", "N Denominator", "n Agree", "Percent Agreement", "(LB, UB)")
colnames(tab.12b) = c("Tumor Type", "Variant Type", "PRESENT/PRESENT",	"PRESENT/ABSENT",
"ABSENT/ABSENT",	  "ABSENT/PRESENT",
"PRESENT/IND",     "ABSENT/IND")
write_csv_to_s3(tab.12a, 's3://archer-stats-data-management/Stratafide/ctDNA/DHF17-A-3-2/STAT/STAT_ANALYSIS_OUTPUT/AgreementStatTumVT.csv')
write_csv_to_s3(tab.12b, 's3://archer-stats-data-management/Stratafide/ctDNA/DHF17-A-3-2/STAT/STAT_ANALYSIS_OUTPUT/Counts_for_Agreement_TumVT.csv')
# -----
# Table 13a. Agreement for Wild Type Variants (No Calls Excluded)
# Table 13b. Counts for Agreement for Wild Type Variants (No Calls Excluded)
wtchrpos = c("chr1-114713908", "chr1-114713909", "chr2-29209798", "chr2-29220829", "chr2-208248389",
"chr2-208248389", "chr3-41224633", "chr3-41224642", "chr3-41224646", "chr3-179218303",
"chr3-179234297", "chr4-1801837", "chr4-1801841", "chr4-1804362", "chr4-1806162",
"chr4-54727434", "chr4-54727442", "chr4-54727495", "chr4-54727500", "chr4-54733155", "chr6-152098791",
"chr7-55154129", "chr7-55174015", "chr7-55174769", "chr7-55174771", "chr7-55181378",
"chr7-55191822", "chr7-55191831", "chr7-116771986", "chr7-140753336", "chr10-43121968", "chr10-121520163",
"chr12-25225628", "chr12-25227341", "chr12-25245347", "chr12-25245350", "chr12-25245350", "chr12-25245350",
"chr12-25245351", "chr14-104780214", "chr15-90088606", "chr15-90088702", "chr17-7675088", "chr17-39711955",
"chr17-39723405", "chr17-39723965", "chr17-39723967", "chr17-39724728", "chr17-39724747", "chr17-39725079")
tab.13a = c()
tab.13b = c()
for (aset in analysis_sets){
for (muttype in muttypes[1:2]){
print(paste("Secondary Analysis (WT variant level)", aset, muttype,"...",sep=" "))
Xpp = 0
Xnp = 0
Xpn = 0
Xnn = 0
Xip = 0
Xin = 0
for (i in 1:nrow(maxValConcordanceChrPosLevelAnno)){
if (maxValConcordanceChrPosLevelAnno[i,"mutation_class"] != muttype){
next
}
if (!(maxValConcordanceChrPosLevelAnno[i,"chrpos"] %in% wtchrpos)){
next
}
if (aset == "Commercial panel specimens" & maxValConcordanceChrPosLevelAnno[i,"tissue_kind"] != "Commercial/Cell line"){
next
}
if (aset == "Clinical specimens" & maxValConcordanceChrPosLevelAnno[i,"tissue_kind"] == "Commercial/Cell line"){
next
}
# if both detect or not detect concordantly (Xpp and Xnn)
# otherwise use the LoD requirement to establish discordant calls
if (maxValConcordanceChrPosLevelAnno[i,"top_stratafide_call"] != "n/a" &
maxValConcordanceChrPosLevelAnno[i,"top_avenio_call"]     != "n/a"){
Xpp = Xpp + 1
}else if(maxValConcordanceChrPosLevelAnno[i,"top_stratafide_call"] == "n/a" &
maxValConcordanceChrPosLevelAnno[i,"top_avenio_call"]     == "n/a"){
Xnn = Xnn + 1
}else if(maxValConcordanceChrPosLevelAnno[i,"top_stratafide_call"] != "n/a" &
maxValConcordanceChrPosLevelAnno[i,"top_avenio_call"]     == "n/a"){
threshold = avenioSNVIndelLOD
if (muttype == "CNV"){
threshold = 0
}
if (as.numeric(maxValConcordanceChrPosLevelAnno[i,"top_strat_AF_or_CNV_obs_copies"])  >= threshold){
Xpn = Xpn + 1
}
}else if(maxValConcordanceChrPosLevelAnno[i,"top_stratafide_call"] == "n/a" &
maxValConcordanceChrPosLevelAnno[i,"top_avenio_call"]     != "n/a"){
threshold = avenioSNVIndelLOD
if (muttype == "CNV"){
threshold = avenioCNVLoD
}
if (as.numeric(maxValConcordanceChrPosLevelAnno[i,"top_avenio_AF_or_CNV_score"])  >= threshold){
Xnp = Xnp + 1
}
}
} # end of i loop
# compute the full NPA, OPA we need to infer to the TN counts
# based on mutation type
mutN = 3 # for CNVs if included
if (muttype == "SNV"){
mutN = 40 # this is the shared SNV/MNV position coverage between assays
}
if (muttype == "Indel"){
mutN = 10  # this is the shared Indel position coverage between assays
}
Xnn = nrow(comparison_manifest)*mutN - Xpp - Xpn - Xnp
OPAres = c(muttype, "OPA", prctAggResRow((Xpp+Xnn), (Xpp+Xnp+Xpn+Xnn)))
PPAres = c(muttype, "PPA", prctAggResRow(Xpp, Xpp+Xnp))
NPAres = c(muttype, "NPA", prctAggResRow(Xnn, Xnn+Xpn))
tab.13a = rbind(tab.13a, c(aset,OPAres),
c(aset,PPAres),
c(aset,NPAres))
tab.13b = rbind(tab.13b, c(aset,muttype,Xpp,Xnp,Xnn,Xpn,Xip,Xin))
}
}
tab.13a = data.frame(tab.13a)
tab.13b = data.frame(tab.13b)
colnames(tab.13a) = c("Analysis Set", "Variant Type", "Comparison", "N Denominator", "n Agree", "Percent Agreement", "(LB, UB)")
colnames(tab.13b) = c("Analysis Set", "Variant Type", "PRESENT/PRESENT",	"PRESENT/ABSENT",
"ABSENT/ABSENT",	  "ABSENT/PRESENT",
"PRESENT/IND",     "ABSENT/IND")
write_csv_to_s3(tab.13a, 's3://archer-stats-data-management/Stratafide/ctDNA/DHF17-A-3-2/STAT/STAT_ANALYSIS_OUTPUT/AgreementStatWT.csv')
write_csv_to_s3(tab.13b, 's3://archer-stats-data-management/Stratafide/ctDNA/DHF17-A-3-2/STAT/STAT_ANALYSIS_OUTPUT/Counts_for_Agreement_WT.csv')
A<-read.table("~/Desktop/myfile.txt", sep="\t", header=TRUE)
head(A)
dim(A)
A<-read.table("~/Desktop/myfilesimple.txt", sep="\t", header=TRUE)
head(A)
summary(A)
t.test(1:10, 20:30)
myttoutput <-  t.test(1:10, 20:30)
summary(myttoutput)
myttoutput$p.value
wilcox.test(1:10, 20:30)
mywilcoxtestoutput <- wilcox.test(1:10, 20:30)
summary(mywilcoxtestoutput)
mywilcoxtestoutput$p.value
library(pheatmap)
install.packages("pheatmap")
install.packages("pheatmap")
library(pheatmap)
test = matrix(rnorm(200), 20, 10)
head(test)
dim(test)
test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] + 3
test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)] + 2
test[15:20, seq(2, 10, 2)] = test[15:20, seq(2, 10, 2)] + 4
colnames(test) = paste("Test", 1:10, sep = "")
rownames(test) = paste("Gene", 1:20, sep = "")
head(test)
pheatmap(test)
head(A)
rownames(A) = A$ECNumber
colnames(A)
inputA = A[,-c(1)]
head(inputA)
pheatmap(test)
pheatmap(inputA)
